package com.droidrun.portal.events

import android.util.Log
import com.droidrun.portal.events.model.EventType
import com.droidrun.portal.events.model.PortalEvent
import org.java_websocket.WebSocket
import org.java_websocket.handshake.ClientHandshake
import org.java_websocket.server.WebSocketServer
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import com.droidrun.portal.service.ActionDispatcher
import com.droidrun.portal.config.ConfigManager
import org.json.JSONObject

class PortalWebSocketServer(
    port: Int,
    private val actionDispatcher: ActionDispatcher,
    private val configManager: ConfigManager,
) : WebSocketServer(InetSocketAddress(port)) {
    
    companion object {
        private const val TAG = "PortalWSServer"
    }

    // TODO test it
    override fun onWebsocketHandshakeReceivedAsServer(
        conn: WebSocket?,
        draft: org.java_websocket.drafts.Draft?,
        request: ClientHandshake?
    ): org.java_websocket.handshake.ServerHandshakeBuilder {
        val descriptor = request?.resourceDescriptor ?: ""
        
        // Check for token in header
        var token = request?.getFieldValue("Authorization")
        if (token != null && token.startsWith("Bearer ")) {
            token = token.substring(7).trim()
        }
        
        // Fallback: Check query param (e.g. /?token=abc)
        if (token.isNullOrEmpty() && descriptor.contains("token=")) {
            val query = descriptor.substringAfter("?")
            val params = query.split("&")
            for (param in params) {
                if (param.startsWith("token=")) {
                    token = param.substring(6)
                    break
                }
            }
        }

        // Validate Token
        if (token != configManager.authToken) {
            Log.w(TAG, "Rejecting connection: Invalid or missing token")
            throw org.java_websocket.exceptions.InvalidDataException(401, "Unauthorized")
        }

        return super.onWebsocketHandshakeReceivedAsServer(conn, draft, request)
    }

    override fun onOpen(conn: WebSocket?, handshake: ClientHandshake?) {
        Log.d(TAG, "New connection from ${conn?.remoteSocketAddress}")
    }

    override fun onClose(conn: WebSocket?, code: Int, reason: String?, remote: Boolean) {
        Log.d(TAG, "Connection closed: $reason")
    }

    override fun onMessage(conn: WebSocket?, message: String?) {
        if (message == null) return
        
        try {
            val json = JSONObject(message)
            val id = json.optString("id")
            val method = json.optString("method")
            
            if (id.isNotEmpty() && method.isNotEmpty()) {
                // Command Request
                val params = json.optJSONObject("params") ?: JSONObject()
                
                val result = actionDispatcher.dispatch(method, params)
                
                if (result is com.droidrun.portal.api.ApiResponse.Binary) {
                    // Binary Response: [UUID (36 bytes)] + [Data]
                    val uuidBytes = id.toByteArray(Charsets.UTF_8)
                    // ensuring UUID is 36 bytes (it should be if generated by python uuid4)
                    // If not, maybe need padding or fixed size.
                    // Python UUID str is 36 chars = 36 bytes in UTF-8/ASCII.
                    
                    val payload = ByteBuffer.allocate(uuidBytes.size + result.data.size)
                    payload.put(uuidBytes)
                    payload.put(result.data)
                    payload.flip()
                    conn?.send(payload)
                } else {
                    // Text Response
                    val response = JSONObject()
                    response.put("id", id)
                    
                    val apiResponseJson = JSONObject(result.toJson())
                    
                    if (apiResponseJson.getString("status") == "success") {
                        response.put("status", "success")
                        response.put("result", apiResponseJson.opt("data"))
                        response.put("error", JSONObject.NULL)
                    } else {
                        response.put("status", "error")
                        response.put("result", JSONObject.NULL)
                        response.put("error", apiResponseJson.opt("error") ?: "Unknown error")
                    }
                    
                    conn?.send(response.toString())
                }
                
            } else {
                // Fallback for legacy events (if any) or ping
                val commandEvent = PortalEvent.fromJson(message)
                handleCommand(conn, commandEvent)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error processing message: ${e.message}")
        }
    }

    override fun onMessage(conn: WebSocket?, message: ByteBuffer?) {
        // Handle binary messages if needed
    }

    override fun onError(conn: WebSocket?, ex: Exception?) {
        Log.e(TAG, "WebSocket Error: ${ex?.message}")
    }

    override fun onStart() {
        Log.i(TAG, "WebSocket Server started on port $port")
        
        // Register ourselves with the Hub to receive events
        EventHub.subscribe { event ->
            broadcast(event.toJson())
        }
    }
    
    private fun handleCommand(conn: WebSocket?, event: PortalEvent) {
        when (event.type) {
            EventType.PING -> {
                val pong = PortalEvent(EventType.PONG, payload = "pong")
                conn?.send(pong.toJson())
            }
            else -> {
                Log.d(TAG, "Received unhandled event: ${event.type}")
            }
        }
    }
    
    // Helper to safely stop
    fun stopSafely() {
        try {
            stop()
        } catch (e: Exception) {
            Log.e(TAG, "Error stopping server", e)
        }
    }
}
